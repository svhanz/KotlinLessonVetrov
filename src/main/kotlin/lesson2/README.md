## Создание файла в Котлин
Классические операции, такие как сложение, вычитание, умножение, деление – в языке программирования Kotlin
работают по тем же законам, что и в математике и используются точно такие же операторы.<br>
Перед тем, как начнем практиковаться, произведем небольшой рефакторинг и наведем в проекте порядок.<br>
Чтобы материалы не путались, я буду создавать отдельный файл под каждый урок.<br> Сначала переименуем файл первого урока.<br>
Жмем на него ПКМ → Refactor → Rename. Пусть название будет, например, lesson_1.<br>
Переименование через рефактор в проекте следует использовать по возможности всегда, вне зависимости от того,
что вы переименовываете (файл, класс, переменную или метод).<br> 
Если вы захотите переименовать переменную,
которая используется в разных местах проекта, таким образом она изменится везде.

Чтобы создать новый файл, жмем на папку kotlin ПКМ → New → Kotlin Class/File. Назовем соответственно lesson_2.<br>
Пишем новую точку входа в приложение с помощью стандартной функции main().<br>
Чтобы код внутри фигурных скобок стал исполняемым. Отлично, мы готовы к практике.

## Инициализация числом и выражением
Математические операторы выглядят точно также, поэтому долго не будем останавливаться на базовых операциях.<br>
Давайте объявим несколько переменных, с которыми будем сейчас работать:
```
val a = 5
val b = 7
println(a + b)
```
Вызовем метод println() и отправим в него выражение. Например, сумму этих чисел и распечатаем.<br>
Также результат можно записать в отдельную переменную, например, назовем ее sum и распечатаем результат:
```
val a = 5
val b = 7
val sum = a + b
println(sum)
```
В обоих случаях в консоли отобразится результат сложения двух чисел.<br>
Можете поэкспериментировать с более сложными выражениями – разными знаками и дополнительными скобками.<br>
Смотрите, проинициализировать переменную можно как обычным числом, так и неким выражением сразу.<br> 
В последнем случае результат сначала будет посчитан, а затем присвоен переменной sum.

Еще несколько нюансов, которые также стоит записать в свой конспект, про объявление и инициализацию
переменных любого типа.<br>
Нельзя просто так взять и объявить переменную с одним только названием,
не проинициализировав ее или не указав тип. Например, `val c`.<br>
Среда разработки подсветит ошибку, а программа упадет на этапе компиляции.<br>
Это произойдет, потому что компилятору непонятно, в итоге какого типа будет переменная.<br>
Поэтому в такой ситуации можно пойти двумя путями:
- при объявлении переменной сразу проинициализировать ее, тогда тип присвоится автоматически;
- при объявлении переменной принудительно указывать ее тип – например, `val c: Int`.
## Деление целых и дробных чисел
Естественно, в метод println() можно отправлять данные не только через переменные,
а напрямую любые нетипизированные выражения. Например, разделим два числа:
`println(10 / 3) // 3`
Почему так, если точно известно, что результатом будет дробное число? Дело в той же типизации. 
Мы передали в функцию println() целые числа, поэтому результат вычисления тоже будет распечатан с сохранением типа.
В котлине при делении целых чисел, дробная часть отбрасывается. Давайте для наглядности покажу,
как будет отличаться вывод одних и тех же чисел, явно указав разные типы.

Сначала еще раз присвоим два наших целых числа с явным указанием целочисленного типа. 
Запишем выражения деления в консоль. Далее по такому же принципу я распишу деление двух чисел типа Float
и двух чисел типа Double. Также еще раз вспомним разницу в их объявлении.
```
val intNum1: Int = 10
val intNum2: Int = 3
println(intNum1 / intNum2) // 3

val floatNum1: Float = 10f
val floatNum2: Float = 3f
println(floatNum1 / floatNum2) // 3.3333333

val doubleNum1: Double = 10.0
val doubleNum2: Double = 3.0
println(doubleNum1 / doubleNum2) // 3.3333333333333335
```
Помним, что для инициализации дробного числа типа Float добавляем f в конце значения. 
Для инициализации дробного числа типа Double просто делаем его дробным, добавив точку. 
Теперь распечатываем значения в консоль. Разница очевидна. Напомню, double и float отличаются 
только максимально возможным объемом хранимого числа. Итог: чтобы получить дробное число,
нужно позаботиться об его явной типизации при объявлении.

Остаток от деления
В Kotlin есть оператор, который позволяет получить остаток от деления на число. Как мы понимаем,
остаток от деления при делении 10 на 3 будет 1. Чтобы получить это значение в коде, используется знак %.
Например:
`println(10 % 3) // 1`

Самый популярный метод применения этого оператора – это определения четности или нечетности целого числа. 
Если остаток от деления на 2 – ноль, значит это число четное.

Как в Kotlin формируется конечный тип переменной
Что если в выражении встретились два разных типа? Например Int и Double. Какой тип сохранится в качестве результата? 
Рассмотрим на примере.
Для вычислений будем использовать наши же переменные, которые мы проинициализировали выше.
```
val c = intNum1 + floatNum1
println(c::class.simpleName) // float
val d = intNum1 + floatNum1 + doubleNum1
println(d::class.simpleName) // double
```
Первое - Если в выражении присутствует одновременно целочисленный и дробный типы, то 
результат вычислений будет всегда дробный.

Второе - Если среди вычислений будут одновременно типы Float и Double – в этом случае результат вычислений
будет иметь тип Double. За счет преимущества по объему вмещаемой памяти (8 байт у Double против 4 у Float).

Кстати, чтобы в коде распечатать тип переменной, нужно дописать оператор “двойное двоеточие” и ключевое слово class. 
Оператор `::` является ссылкой на метод или класс. Если вам нужна ссылка на Kotlin класс,
то достаточно написать `::class.` 
Если нужно просто получить имя класса, то в конце необходимо добавить `.simpleName`. 
Таким образом мы обратимся к полю имени класса.

Так мы вызвали метод, который вернул нам (в место вызова) имя класса, его описание можно прочитать в документации 
стандартной библиотеки. Для этого нужно кликнуть на метод с зажатой клавишей command или ctrl. 
Сейчас этот момент может быть непонятен, ничего страшного, к классам и объектам мы вернемся позже
и все подробно разберем. Пока это демонстрация, как читать оригинальные описания работы разных стандартных методов.

## Присваивание через +=, инкремент, декремент в Котлин
Теперь немного поговорим об укороченных записях некоторых операций. Очень распространенные конструкции. 
Представим, мы делаем какой-нибудь счетчик, неважно как, но суть в том, 
что нам надо каждую секунду добавлять к числу единицу.
Объявим изменяемую переменную с названием, например, counter (счетчик) и присвоим ей 0. 
Прибавлять единицу можно несколькими способами:
- присваиваем переменной результат суммы значения текущей переменной и единицы
`counter = counter + 1`
- используем оператор сложения с присваиванием +=
`counter += 1`
- используем оператор инкремента ++
`val f = counter++`
Все эти операторы делают одно и то же. Точно также можно отнимать единицу, используя оператор вычитания
с присваиванием и декремента (два минуса):
``
counter -= 1
counter--
``
Инкремент и декремент тут показаны в постфиксной форме. Также их можно применять и в префиксной форме,
поставив плюсы перед переменной:
``
++counter
--counter
``
Такие тонкие настройки могут понадобиться, когда, например, надо сначала увеличить значение на единицу, 
а затем использовать и наоборот.

## Операторы сравнения 
Наконец пройдемся по операторам сравнения. Мы проинициализировали ранее две переменные a и b. 5 и 7. 
Используем их. В методе println запишем различные варианты сравнения двух целых чисел и сразу распечатаем результаты:
``
println(a > b) // false
println(a < b) // true
println(a >= b) // false
println(a <= b) // true
println(a == b) // false
println(a != b) // true
``
Каждый из них возвращает результат сравнения типа Boolean. 
Напомню, переменные этого типа могут хранить в себе только два значения: истину или ложь. 
Именно этот результат мы увидим в консоли.

